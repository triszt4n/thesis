\chapter{Rétegeken átívelő szolgáltatások implementációja}

Ebben a fejezetben kerül kifejtésre az implementációja azon szolgáltatásoknak az alkalmazásban, amelyek a kliens és szerver rétegén átívelnek, így külön-külön nem lenne érdemes bemutatni őket.

\section{Single Sign-On (SSO) integrációja}

A videók feltöltésére azok jogosultak, akik a stúdióba be tudnak lépni a \verb|/studio| aloldalon, a bejelentkeztetéshez pedig a kari hallgatói közösségünk által nyílt forráskóddal fejlesztett AuthSCH nevű SSO-rendszert integráltam be a weboldalba, ennek az esszenciális tokenkezelési implementációs részeit a backendre bíztam, a kliensoldal csupán a megfelelő útvonalakra irányításért felel.

A \ref{lst:authCtx}. kódrészlet mutatja be a React-alkalmazásban használt \verb|AuthCtx| nevű kontextust, amely JSON Web Tokeneket (JWT)\cite{jwt} használ a bejelentkeztetés során a felhasználói adatok biztonságos és állapotmentes átpasszolására. A \verb|useMe| nevű hook a backend \verb|/api/auth/me| végpontjáról kéri le a bejelentkezett felhasználó adatait, a végpont mögötti logika csupán annyiból áll, hogy kibontja a kódolt JWT-t és visszaadja abból a releváns profiladatokat. Az \verb|AuthProvider| nevű React-függvénykomponens biztosítja a kontextust az alkalmazás többi részének, a \verb|useAuth| hookon keresztül lehet indítani a többi komponensekben bejelentkezést és kijelentkezést (\verb|login| és \verb|logout| függvények), lehet megtudni, van-e bejelentkezett felhasználó a rendszerben (\verb|authenticated| boolean változó).

\begin{minipage}{0.92\textwidth}
  \begin{lstlisting}[
  caption=auth-context.tsx fájl tartalma.,
  label=lst:authCtx,
  style=js,
  basicstyle=\fontsize{10}{12}\ttfamily
]
import { createContext, PropsWithChildren } from "react"
import { useMe } from "./use-me.hook"

type AuthCtxType = {
  authenticated: boolean
  isLoading: boolean
  login: () => void
  logout: () => void
}
export const AuthCtx = createContext<AuthCtxType | undefined>(undefined)

export function AuthProvider({ children }: PropsWithChildren) {
  const { data, isLoading } = useMe()
  const onLogin = async () => {
    window.location.href = import.meta.env.VITE_BACKEND_URL+"/auth/login"
  }
  const onLogout = async () => {
    window.location.href = import.meta.env.VITE_BACKEND_URL+"/auth/logout"
  }
  const value = {
    authenticated: !!data,
    isLoading,
    login: onLogin,
    logout: onLogout,
  }
  return <AuthCtx.Provider value={value}>{children}</AuthCtx.Provider>
}
export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider")
  }
  return context
}
\end{lstlisting}
\end{minipage}

A szerver oldalán egy \verb|AuthModule| névre hallgató NestJS-modul került létrehozásra, amely a \verb|AuthController| és \verb|AuthService| osztályokat tartalmazza. Az \verb|AuthController| osztályban kerülnek definiálásra a forgalmat lehallgató HTTP-végpontok/függvények, míg az \verb|AuthService| osztály elkülöníti a konkrét üzleti logikát. A \ref{lst:authController}. kódrészlet bemutat két fontos HTTP-végpontot, a \verb|/api/auth/login| és a \verb|/api/auth/callback| útvonalakon GET metódusra hallgatóakat sorrendben.

\begin{minipage}{0.92\textwidth}
  \begin{lstlisting}[
    caption=Az AuthController osztály fontos függvényei.,
    label=lst:authController,
    style=js,
    basicstyle=\fontsize{10}{12}\ttfamily
  ]
@UseGuards(AuthSchGuard)
@Get("login")
@ApiFoundResponse({
  description: "Redirects to the AuthSch login page.",
})
login() {}

@Get("callback")
@UseGuards(AuthSchGuard)
@ApiFoundResponse({
  description: "Redirects to the frontend and sets cookie with JWT.",
})
@ApiQuery({ name: "code", required: true })
oauthRedirect(@CurrentUser() user: UserDto, @Res() res: Response): void {
  const jwt = this.authService.login(user)
  res.cookie("jwt", jwt, {
    httpOnly: true,
    secure: true,
    domain: process.env.NODE_ENV === "production" ? getHostFromUrl(process.env.FRONTEND_CALLBACK) : undefined,
    maxAge: 1000 * 60 * 60 * 24 * 7, // 7 days
  })
  res.redirect(302, process.env.FRONTEND_CALLBACK + "?authenticated=true")
}
\end{lstlisting}
\end{minipage}

A \verb|AuthSchGuard| egy NestJS-dekorátor, amely fel kell kerüljön a \verb|oauthRedirect| és \verb|login| függvényekre. E mögött a dekorátor mögött egy Passport.js-stratégia\cite{passport} van, amely megvalósítja az AuthSCH-val való OAuth-alapú beazonosítási logikát az OAuth-token megújítását, ehhez kell beállítja a kapott OAuth-kliens azonosítóját és titkos kulcsát, ezen értékek forrásáról később a \ref{sec:envvars}. alfejezet beszél.

A \verb|login| függvényt maga az \verb|AuthSchGuard| dekorátor kiváltja, a függvény törzsébe nem kell semmit se írni, a mögöttes logika a felhasználót átirányítja az AuthSCH bejelentkezési oldalára. Az \verb|oauthRedirect| függvény a sikeres bejelentkezés után visszairányítja a felhasználót a frontendre, a kérésben a \verb|jwt| nevű HTTP-only biztonságos sütit beállítja, amely tartalmazza a bejelentkezett felhasználóra jellemző JWT-t 7 napos lejárati idővel. A \verb|@CurrentUser()| dekorátor a bejelentkezett felhasználó adatait injektálja a megadott \verb|user| paraméterbe (ezt az \verb|AuthSchGuard| oldja meg a háttérben, kiolvassa a kapott autorizációs kódot, amit az AuthSCH-tól kapott). Az \verb|AuthService| osztály \verb|login| függvénye a bejelentkezett AuthSCH-s felhasználó adatait kapja meg, amelyből a JWT-t generálja, ezt a \ref{lst:authService}. kódrészlet mutatja be. A \verb|createOrUpdateUser| függvény a Prisma ORM segítségével megkeresi a felhasználót az adatbázisban, ha nem találja, akkor létrehozza azt, ha megtalálja, akkor frissíti a felhasználó adatait, ez a függvény kerül felhasználásra az \verb|AuthSchGuard| mögötti stratégiában is a bejelentkeztetés validációs ``mellékhatásaként'', hogy a saját adatbázisunkban is létrejöjjön a felhasználó.

\begin{minipage}{0.92\textwidth}
  \begin{lstlisting}[
    caption=Az AuthService osztály fontos függvényei.,
    label=lst:authService,
    style=js,
    basicstyle=\fontsize{10}{12}\ttfamily
  ]
login(user: object): string {
  return this.jwtService.sign(user, {
    secret: this.configService.get<string>("JWT_SECRET"),
    expiresIn: "7 days",
  })
}
async createOrUpdateUser(prof: AuthSchProfile): Promise<UserDto> {
  const gravatarUrl = this.getGravatarUrl(prof.email, 200)
  return this.prisma.user.upsert({
    where: { authSchId: prof.authSchId },
    update: {
      fullName: prof.fullName,
      firstName: prof.firstName,
      email: prof.email,
      imageUrl: gravatarUrl,
    },
    create: {
      authSchId: prof.authSchId,
      fullName: prof.fullName,
      firstName: prof.firstName,
      email: prof.email,
      imageUrl: gravatarUrl,
    },
  })
}
\end{lstlisting}
\end{minipage}

Lefejlesztésre került egy másik \emph{guard} típusú NestJS-dekorátor, ez a \verb|JwtGuard|, amelyet minden más a szerveren található végpontra be kell vezetni, amennyiben az bejelentkezett felhasználót igényel, ez a dekorátor ellenőrzi a \verb|jwt| süti jelenlétét, a felhasználót beazonosítja. Az ilyen függvényekben is ha a paraméterre egy \verb|@CurrentUser()| dekorátort helyezünk, akkor a felhasználó adatai automatikusan be lesznek injektálva abba a paraméterbe.
