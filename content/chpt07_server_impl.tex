\chapter{Szerveroldali folyamatok implementációi}

A megjelenítési réteg alatt található szerveroldali folyamatok implementációja során a kiszolgáló infrastruktúra kialakítására, a Node.js alkalmazás fejlesztésére, a konténerizált környezet kialakítására, valamint a videófeldolgozásra fókuszálunk ebben a fejezetben.

\section{A virtuális privát felhő komponensei}

TODO: A VPC-beli (Virtual Private Cloud) subnetek, a security groupok, route táblák. A biztonság vizsgálata.

\begin{figure}[ht]
  \centering
  \includegraphics[width=150mm, keepaspectratio]{figures/dipterv_vpc.png}
  \caption{Részletes architektúraábra a VPC-ről.}
  \label{fig:vpc}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=152mm, keepaspectratio]{figures/hostmgmt.png}
  \caption{A Host Management gyorstelepítési oldala.}
  \label{fig:hostmgmt}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=150mm, keepaspectratio]{figures/server_roles.png}
  \caption{Felhasznált IAM-szerepkörök a rendszerben.}
  \label{fig:roles}
\end{figure}

TODO: alternatíva a NATGW-vel. Lehettek volna VPC Endpointok pl. így: https://www.cloudkeeper.com/insights/blog/how-optimize-vpc-endpoint-amazon-ecr-images Probléma: az ECS nem tud auth.sch-ra hívni, mert privát subnetben van. Ezért kikerül a privát subnetből, ezért nem lesz a VPCE-kre se szükség :c ugyanis a NAT Gateway nagyon drága volna, most nincs humorom azt üzemeltetni :/
Rohadtul nem biztonságos, de public subnetbe tettem az ECS taskot, hogy tudjon pullolni image-et. VPC Endpoint és a NAT Gateway havi 30 dolláromba fájna.

\section{A Node.js alkalmazás fejlesztése}

TODO: Az elkészült alkalmazás felépítése, a különböző rétegek, a routing, a middleware-ek, a kontrollerek, a service-ek, a REST API.

TODO: Itt lehet szó az adatbázisbeli entitásokról is.

TODO: Kódrészletei. Kitérve arra, hogy miképp könnyíti a munkát a Prisma, milyen egyéb szolgáltatások kerültek be, mi a felépítése a reponak, miért választottam ezt a stacket.

TODO: S3 bucketba való mentése a videónak egy érdekes rész.

\section{A konténerizált környezet}

TODO: Leírás, hogy miért választottam a konténerizált környezetet, a konténerizálás előnyeit, hátrányait. Hogy használható ki a legjobban a konténerizáció az Application Load Balancer-rel együtt. Miképp kapcsoltam ezt a kettőt össze (ECS service, ALB).

\begin{minipage}{0.92\textwidth}
\begin{lstlisting}[
  caption=API stack moduljának felparaméterezése a main.tf fájlban.,
  label=lst:mainApi,
  style=tf,
  basicstyle=\fontsize{10}{12}\ttfamily
]
module "api" {
  source = "./modules/api-stack"
  environment = var.environment
  vpc_id = module.vpc.vpc_id

  alb_tg_port_mapping = 80
  alb_secgroup_ids = [module.vpc.secgroups["streamzen-alb-sg"].id]
  alb_subnet_ids = [module.vpc.subnets["streamzen-alb-1a"].id, module.vpc.subnets["streamzen-alb-1b"].id]
  alb_internal = true # does not need to be internet-facing
  db_secgroup_ids = [module.vpc.secgroups["streamzen-db-sg"].id]
  db_subnet_ids = [module.vpc.subnets["streamzen-private-1a"].id, module.vpc.subnets["streamzen-private-1b"].id]
  api_secgroup_ids = [module.vpc.secgroups["streamzen-api-sg"].id]
  api_subnet_ids = [module.vpc.subnets["streamzen-public-1a"].id, module.vpc.subnets["streamzen-public-1b"].id]
  api_subnet_route_table_ids = [for s in values(module.vpc.subnets) : s.route_table_id]

  ecs = {
    family_name = "streamzen-api"
    port_mapping = 80
    task_environment = {
      AUTHSCH_CLIENT_ID = data.aws_ssm_parameter.these["authsch-client-id"].value
      AUTHSCH_CLIENT_SECRET = data.aws_ssm_parameter.these["authsch-client-secret"].value
      POSTGRES_USER = data.aws_ssm_parameter.these["db-username"].value
      POSTGRES_PASSWORD = data.aws_ssm_parameter.these["db-password"].value
      POSTGRES_PRISMA_URL = "postgresql://${data.aws_ssm_parameter.these["db-username"].value}:${data.aws_ssm_parameter.these["db-password"].value}@streamzen-rds-dev.czw6iqm8461h.eu-central-1.rds.amazonaws.com:5432/streamzen?schema=public"
      FRONTEND_CALLBACK = "https://${var.domain_name}"
      JWT_SECRET = data.aws_ssm_parameter.these["api-jwt-secret"].value
      AWS_S3_REGION = var.region
      AWS_S3_UPLOADED_BUCKET = "streamzen-uploaded-videos-${var.environment}-bucket"
    }
    memory = 512
    cpu = 256
    desired_task_count = var.enable_ecs ? 1 : 0
  }
  db = {
    engine = "postgres"
    engine_version = "16.4"
    instance_class = "db.t3.micro"
  }
}
\end{lstlisting}
\end{minipage}

\subsection{A Node.js szerveralkalmazás ECS-en}

TODO: Az ECS orkesztrációs toolsetjének kialakítása, a konténer rétegződés felépítése ECS-ben, a konténer registry (ECR) bekötése. Környezeti változók, portok, ALB-re való kötése. Miből állt a dockerizálás nekem (Dockerfile, registry, image build, push, networking).

TODO: Milyen IAM role-okat kellett feltenni rá, mikkel kommunikál kifelé, mi indokolta, hogy publikus subnetbe kerüljön. Hogy hív meg más külső rácsatlakozó erőforrásokat (S3 bucket, RDS instance, Lambda függvény, MediaLive channel).

TODO: Jumpbox használata, illetve miért került ki, hol volt egy hibázás a Dockerfile-lal.

\begin{minipage}{0.92\textwidth}
  \begin{lstlisting}[
  caption=Dockerfile tartalma.,
  label=lst:dockerfile,
  style=dockerfile,
  basicstyle=\fontsize{10}{12}\ttfamily
]
# Stage 1: Build the application
FROM node:20-alpine AS build
ENV NODE_ENV=development
WORKDIR /app
COPY package.json ./
COPY yarn.lock ./
COPY .yarnrc.yml ./
COPY prisma ./prisma/
RUN corepack enable
RUN yarn install
COPY . .
RUN npx prisma generate
RUN yarn build

# Stage 2: Create a lightweight container with the built app
FROM node:20-alpine AS production
ENV NODE_ENV=production
WORKDIR /app
COPY --from=build /app/dist ./dist
COPY --from=build /app/package.json ./package.json
COPY --from=build /app/yarn.lock ./yarn.lock
COPY --from=build /app/.yarnrc.yml ./.yarnrc.yml
COPY --from=build /app/prisma ./prisma
RUN corepack enable
RUN yarn install --immutable
RUN npx prisma generate
CMD ["npm", "run", "start:migrate:prod"]
\end{lstlisting}
\end{minipage}

\subsection{A szerveralkalmazás CI/CD folyamatai}

TODO: GitHub Actions a smoke tesztre, a deploymentre: Docker build és ECR-be telepítés.

\section{Elemental MediaConvert felhasználása}

TODO: Az Elemental MediaConvert API használata a Lambdából, illetve hogy hogy hívódik meg a Lambda, milyen triggerrel, milyen környezeti változókkal, milyen IAM role-al. Hogy kellett felkonfigurálni a MediaConvert job, hogy kellett magát a Lambdát felkonfigolni, hogy tudja is hívni.
